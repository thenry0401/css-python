하드는 처리속도가 느리다
램은 하드보다는 빠르다. 그러나 cpu 안의 레지스터 보다는 느리다
cpu안의 레지스터는 굉장히 빠르다. 그러나 용량이 작다
그래서 레지스터와 램 사이에서 중개를 하는 캐쉬cache를 이용한다


1. temporal locality : 한번 접근한 메모리는 앞으로도 자주 접근할것임

2. spatial locality : 접근한 메모리의 '근처' 변수(메모리)에 접근한다


램에서부터 자주 쓰는 메소드,함수를 캐쉬가 저장해서 자주사용한다면 더 빠르게 사용할 수 있게 한다
레지스터 <------> 캐쉬 <--------> 램


웹에서도 캐쉬를 쓴다
사용자 <------> proxy server(cache) <------> naver.com
사용자가 어떤걸 요청하면 바로 네이버에 요청되는게 아니고 프록시에 요청해서 프록시 안에 저장돼있으면 바로 호스트에게 전달한다
저장안되있으면 프록시 서버가 네이버에 요청해서 프록시로 가져와서 저장한다

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

10진수 -- 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

2진수 -- 0, 1

16진수 -- 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f



2^5(16) 2^4(16) 2^3(8) 2^2(4) 2^1(2) 2^0(1)

10진수 >>>> 2진수
ex) 17 = 16 + 1 = 2^4 + 2^0 = 10001(2)

    13 = 8 + 5 = 8 + 4 + 1 = 1101(2)
    
    7 = 4 + 2 + 1 = 111(2)
    
    15 = 8 + 4 + 2 + 1 = 1111(2)
    
    74 = 64 + 8 + 2 = 1001010(2)
    
    11111 = 16 + 8 + 4 + 2 +1 = 
    
    10101= 16 + 4 + 1 = 21
    
    1001110 = 64 + 8 + 4 + 2 = 78
    
    
    
2진수 >>> 16진수 바꾸기

2진수 4개 >>> 16진수 1개

16진수 ----------- 2진수

0----------------0000
1----------------0001
2----------------0010


a----------------1010
c----------------1100
f----------------1111


2진수를 16진수로 바꾸는 이유 : 가독성을 좋게 하기위해서... 2진수 4개를 16진수 1개로 줄여서 쓸수있으니깐



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


2의 보수 : 컴퓨터가 음수를 저장하는 방식

1byte --> 8bit
1byte는 256가지를 표현가능 = 숫자로는 0~255까지 나타낼수있따



8bit에서
ㅡㅡㅡㅡㅡㅡㅡㅡ
첫번째 bit에는 부호를 표시하자 >>> 0: 플러스, 1: 마이너스

근데 문제는: 0000 0000은 0이 맞는데, 1000 0000은 -0이라고 문제가 생긴다.


예를들어..
1101 0101
맨앞 1은 마이너스다 그러면
101 0101이 숫자부분임

여기서 0과 1을 반대로 바꾼다

101 0101 >>>> 010 1010

그러고 나서 +1을 해준다

010 1010 + 1 = 010 1011

결국 1101 0101 = -43 이다.



계산기에서 양수를 누르고 나서 not을 누르면 숫자가 하나 커지면서 부호가 마이너스로 바뀜
ex) not(3) = -4
    not(0) = -1


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

부동소수점 : 정확도가 떨어지는 대신에 표현 범위를 엄청나게 넓힌다

if a = 1.4325435 막 이런식으로 쓰면 안된다 
